/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.10.0
 * Wed, 10 Sep 2025 10:31:24 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    function isBlobUrl(obj) {
        return (typeof obj === 'string' && obj.indexOf('blob:') === 0);
    }
        
    function isDataUrl(obj) {
        // NOTE: checking with dataUrlRe is slow
        return (typeof obj === 'string' && obj.indexOf('data:') === 0);
    }
        
    function encodeUnicodeStrToBase64(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
            function toSolidBytes(match, p1) {
                return String.fromCharCode('0x' + p1);
            }
        ));
    }
        
    function convertObjToJsonDataUrl(obj, mime='application/json') {
        if (typeof obj !== 'string') {
            obj = JSON.stringify(obj);
        }
        return 'data:' + mime + ';base64,' + encodeUnicodeStrToBase64(obj);
    }
        
    function convertObjToTextDataUrl(obj) {
        if (typeof obj !== 'string') {
            obj = JSON.stringify(obj);
        }
        return 'data:text/plain;base64,' + encodeUnicodeStrToBase64(obj);
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
        
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function getMaterialEditableValues(matName) {
        const mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (!mat) {
            return [];
        }
    
        if (mat.isMeshNodeMaterial) {
            return Object.keys(mat.nodeValueMap);
        } else if (mat.isMeshStandardMaterial) {
            return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity',
                    'envMapIntensity'];
        } else {
            return [];
        }
    }
        
    function getMaterialEditableColors(matName) {
        const mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (!mat) {
            return [];
        }
    
        if (mat.isMeshNodeMaterial) {
            return Object.keys(mat.nodeRGBMap);
        } else if (mat.isMeshStandardMaterial) {
            return ['color', 'emissive'];
        } else if (mat.isMeshLineMaterial) {
            return ['color'];
        } else {
            return [];
        }
    }
        
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
        
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function getObjectUUID(obj) {
        // auto-generated from a multi-material object, use parent UUID instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.uuid;
        } else {
            return obj.uuid;
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        // css renderer prevents interacting with canvas, in that case we assign events on container
        const elem = appInstance.cssRenderer ? appInstance.container : appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectAmongObjects(objNameToCheck, objUUIDToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        // COMPAT: <4.10, when calling with 2 arguments
        if (Array.isArray(objUUIDToCheck)) {
            objNames = objUUIDToCheck;
            objUUIDToCheck = objNameToCheck;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            const objName = objNames[i];
    
            // COMPAT: < 4.10 (4.9), old engine, new puzzles
            const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
            if ((isID ? objUUIDToCheck : objNameToCheck) === objName) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objName);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        // if parent referred by UUID, compare children also by UUID
                        if (isID ? (objUUIDToCheck === obj.children[j].uuid) : (objNameToCheck === obj.children[j].name)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    class AudioWebAudio {
        constructor() {
            this.audio = new v3d.Audio(new v3d.AudioListener());
    
            this._muted = false;
            this._volume = 1;
        }
    
        load(url) {
            const scope = this;
    
            const xhr = new XMLHttpRequest();
            xhr.open('GET', url);
            xhr.responseType = 'arraybuffer';
    
            xhr.onload = function(e) {
                if (this.status === 200) {
                    // new promise-based syntax is not currently supported in Safari
                    scope.audio.context.decodeAudioData(this.response, function(decodedData) {
                        scope.audio.setBuffer(decodedData);
                    });
                }
            }
    
            xhr.send();
            return this;
        }
    
        play() {
            if (this.audio.buffer === null) return;
            this.audio.play();
        }
    
        pause() {
            this.audio.pause();
        }
    
        stop() {
            if (this.audio.buffer === null || this.audio.source === null) return;
            this.audio.stop();
        }
    
        rewind() {
            if (this.audio.buffer === null || this.audio.source === null) return;
    
            const isPlaying = this.audio.isPlaying;
            this.audio.stop();
            if (isPlaying) {
                this.audio.play();
            }
        }
    
        setPlaybackTime(time) {
            // TODO: not easy with WebAudio
        }
    
        getPlaybackTime() {
            // TODO: not easy with WebAudio
            return 0;
        }
    
        getDuration() {
            return (this.audio.buffer === null) ? 0 : this.audio.buffer.duration;
        }
    
        setPlaybackRate(rate) {
            this.audio.setPlaybackRate(rate);
        }
    
        isPlaying() {
            return this.audio.isPlaying;
        }
    
        setLoop(looped) {
            this.audio.setLoop(looped);
        }
    
        setVolume(volume) {
            this._volume = volume;
            if (!this._muted) {
                this.audio.setVolume(volume);
            }
        }
    
        setMuted(muted) {
            this._muted = muted;
            this.audio.setVolume(muted ? 0 : this._volume);
        }
    
        toPositional() {
            if (!(this.audio instanceof v3d.PositionalAudio)) {
                const posAudio = new v3d.PositionalAudio(this.audio.listener);
                posAudio.fromAudio(this.audio);
                this.audio = posAudio;
            }
            return this.audio;
        }
    }

    return {
        transformCoordsSpace, transformEulerV3dToBlenderShortest, getSceneCoordSystem, getObjectByName,
        RotationInterface, isBlobUrl, isDataUrl, convertObjToJsonDataUrl,
        convertObjToTextDataUrl, bindListener, getElements, retrieveObjectNames,
        getMaterialEditableValues, getMaterialEditableColors, getSceneAnimFrameRate, getSceneByAction,
        getObjectName, getObjectUUID, initObjectPicking, isObjectAmongObjects,
        AudioWebAudio, getElement,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = true;
_initGlob.output.initOptions.preserveDrawBuf = true;
_initGlob.output.initOptions.useCompAssets = false;
_initGlob.output.initOptions.useFullscreen = false;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["camera_defpos"] = camera_defpos;
this.procedures["tube color black"] = tube_color_black2;
this.procedures["tube color darkgray"] = tube_color_darkgray2;
this.procedures["non carbon pvc"] = non_carbon_pvc;
this.procedures["tube color lightgray"] = tube_color_lightgray2;
this.procedures["tube color off white"] = tube_color_off_white;
this.procedures["tube color ice"] = tube_color_ice2;

var PROC = {
    "camera_defpos": camera_defpos,
    "tube color black": tube_color_black2,
    "tube color darkgray": tube_color_darkgray2,
    "non carbon pvc": non_carbon_pvc,
    "tube color lightgray": tube_color_lightgray2,
    "tube color off white": tube_color_off_white,
    "tube color ice": tube_color_ice2,
};

var VARS = Object.defineProperties({}, {
    'is3DLoaded': { get: function() { return is3DLoaded; }, set: function(val) { is3DLoaded = val; } },
    'maincamera_defpos': { get: function() { return maincamera_defpos; }, set: function(val) { maincamera_defpos = val; } },
    'maincamera_targetdefpos': { get: function() { return maincamera_targetdefpos; }, set: function(val) { maincamera_targetdefpos = val; } },
    'rearcamera_pos': { get: function() { return rearcamera_pos; }, set: function(val) { rearcamera_pos = val; } },
    'rearcamera_targetpos': { get: function() { return rearcamera_targetpos; }, set: function(val) { rearcamera_targetpos = val; } },
    'middlecamera_pos': { get: function() { return middlecamera_pos; }, set: function(val) { middlecamera_pos = val; } },
    'middlecamera_targetpos': { get: function() { return middlecamera_targetpos; }, set: function(val) { middlecamera_targetpos = val; } },
    'j': { get: function() { return j; }, set: function(val) { j = val; } },
    'pvc_roughness': { get: function() { return pvc_roughness; }, set: function(val) { pvc_roughness = val; } },
    'mat_dict': { get: function() { return mat_dict; }, set: function(val) { mat_dict = val; } },
    'tube_color': { get: function() { return tube_color; }, set: function(val) { tube_color = val; } },
    'hypalon_roughness': { get: function() { return hypalon_roughness; }, set: function(val) { hypalon_roughness = val; } },
    'tube_color_black': { get: function() { return tube_color_black; }, set: function(val) { tube_color_black = val; } },
    'tube_color_darkgray': { get: function() { return tube_color_darkgray; }, set: function(val) { tube_color_darkgray = val; } },
    'tube_color_lightgray': { get: function() { return tube_color_lightgray; }, set: function(val) { tube_color_lightgray = val; } },
    'tube_color_offwhite': { get: function() { return tube_color_offwhite; }, set: function(val) { tube_color_offwhite = val; } },
    'tube_color_ice': { get: function() { return tube_color_ice; }, set: function(val) { tube_color_ice = val; } },
    'i': { get: function() { return i; }, set: function(val) { i = val; } },
    'bottomcamera_pos': { get: function() { return bottomcamera_pos; }, set: function(val) { bottomcamera_pos = val; } },
    'bottomcamera_tagetpos': { get: function() { return bottomcamera_tagetpos; }, set: function(val) { bottomcamera_tagetpos = val; } },
});

var is3DLoaded, j, pvc_roughness, maincamera_defpos, mat_dict, tube_color, hypalon_roughness, maincamera_targetdefpos, tube_color_black, tube_color_darkgray, tube_color_lightgray, tube_color_offwhite, tube_color_ice, rearcamera_pos, rearcamera_targetpos, middlecamera_pos, middlecamera_targetpos, bottomcamera_pos, bottomcamera_tagetpos, i;

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// getObjTransform puzzle
function getObjTransform(objName, isWorldSpace, mode, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = PzLib.getSceneCoordSystem();

    var transformVal;

    if (isWorldSpace && obj.parent) {
        if (mode === 'position') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldPosition(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'rotation') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldEuler(_pGlob.eulerTmp, 'XYZ'), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'scale') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldScale(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        }

    } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);

    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = PzLib.RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);

    } else {
        transformVal = PzLib.transformCoordsSpace(obj[mode].clone(),
                'Y_UP_RIGHT', coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}

// downloadFile puzzle
function downloadFile(contents, filename) {
    if (!filename)
        return;

    if (contents instanceof Promise) {

        contents.then(function(response) {

            doDownload(response, filename);

        }, function(error) {});

    } else {

        doDownload(contents, filename);

    }

    function doDownload(contents, filename) {
        if (typeof contents !== 'string') {
            contents = PzLib.convertObjToJsonDataUrl(contents);
        } else if (!PzLib.isDataUrl(contents) && !PzLib.isBlobUrl(contents)) {
            contents = PzLib.convertObjToTextDataUrl(contents);
        }

        const link = document.createElement('a');
        link.href = contents;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
            document.body.removeChild(link);
        }, 100);
    }
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// Describe this function...
function camera_defpos() {
    tweenCamera(maincamera_defpos, maincamera_targetdefpos, 1, function() {}, 0);
}

// isObjectVisible puzzle
function isObjectVisible(objSelector) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (obj.visible)
            return true;
    }
    return false;
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// setCSSRuleStyle puzzle
function setCSSRuleStyle(prop, value, id, isParent, mediaRule) {
    const styles = (isParent) ? parent.document.styleSheets : document.styleSheets;
    for (let i = 0; i < styles.length; i++) {
        /**
         * workaround for "DOMException: Failed to read the 'cssRules' property
         * from 'CSSStyleSheet': Cannot access rules"
         */
        let cssRules;
        try {
            cssRules = styles[i].cssRules;
        }
        catch (e) { continue; }

        for (let j = 0; j < cssRules.length; j++) {
            const cssRule = cssRules[j];
            if (!mediaRule && cssRule.selectorText == id)
                cssRule.style[prop] = value;
            else if (mediaRule && cssRule.media && cssRule.media.mediaText == mediaRule) {
                const cssRulesMedia = cssRule.cssRules;
                for (let k = 0; k < cssRulesMedia.length; k++) {
                    if (cssRulesMedia[k].selectorText == id)
                        cssRulesMedia[k].style[prop] = value;
                }
            }
        }
    }
}

// Describe this function...
function tube_color_black2() {
    tube_color = tube_color_black;
}

// Describe this function...
function tube_color_darkgray2() {
    tube_color = tube_color_darkgray;
}

// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = PzLib.getMaterialEditableValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

// Describe this function...
function non_carbon_pvc() {
    setMaterialValue('m_pvc_base', 'normal_pvc_MIX_MixAmount', 0);
}

// Describe this function...
function tube_color_lightgray2() {
    tube_color = tube_color_lightgray;
}

// Describe this function...
function tube_color_off_white() {
    tube_color = tube_color_offwhite;
}

// Describe this function...
function tube_color_ice2() {
    tube_color = tube_color_ice;
}

// setMaterialColor puzzle
function setMaterialColor(matName, colName, r, g, b, cssCode) {

    var colors = PzLib.getMaterialEditableColors(matName);

    if (colors.indexOf(colName) < 0)
        return;

    if (cssCode) {
        var color = new v3d.Color(cssCode);
        r = color.r;
        g = color.g;
        b = color.b;
    }

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var rgbIdx = mat.nodeRGBMap[colName];
            mat.nodeRGB[rgbIdx].x = r;
            mat.nodeRGB[rgbIdx].y = g;
            mat.nodeRGB[rgbIdx].z = b;
        } else {
            mat[colName].r = r;
            mat[colName].g = g;
            mat[colName].b = b;
        }

        // COMPAT: <4.9.0
        if (v3d.engineVersionCmp('4.9.0', v3d.REVISION) < 0)
            mat.needsUpdate = true;

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

// assignMaterial puzzle
function assignMat(objSelector, matName, matIndex) {
    const objNames = PzLib.retrieveObjectNames(objSelector);
    if (!matName)
        return;

    const isMaterialInScene = (mat) => v3d.SceneUtils.getMaterialsByName(appInstance, mat.name).some(iMat => iMat === mat);
    const materialsCache = _pGlob.materialsCache;
    const mat = materialsCache.get(matName) || v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return;
    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i];
        if (!objName)
            continue;
        const obj = PzLib.getObjectByName(objName);
        if (obj) {
            const objsM = obj.resolveMultiMaterial();

            let objM;
            if (Number.isInteger(matIndex)) {
                if (matIndex >= 1 && matIndex <= objsM.length) {
                    objM = objsM[matIndex-1];
                } else {
                    console.error('assign material puzzle: Invalid material index ' + matIndex);
                    continue;
                }
            } else {
                objM = objsM[0];
            }

            const oldMat = objM.material;
            if (!oldMat)
                continue; // pass silently

            objM.material = mat;

            if (!isMaterialInScene(oldMat)) {
                materialsCache.set(oldMat.name, oldMat);
            }
        }
    }

    if (materialsCache.has(mat.name) && isMaterialInScene(mat)) {
        materialsCache.delete(mat.name);
    }
}

_pGlob.animMixerCallbacks = [];

const initAnimationMixer = function() {

    function onMixerFinished(e) {
        const cb = _pGlob.animMixerCallbacks;
        const found = [];
        for (let i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (let i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;

        let scene, frameRate, timeScale, callbacks;

        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();

                if (loop == 'AUTO') {
                    // COMPAT: < 4.10, old engine, new puzzles (no autoParams)
                    if (action.autoParams) {
                        action.loop = action.autoParams.loop;
                        action.repetitions = action.autoParams.repetitions;
                    } else {
                        action.repetitions = Infinity;
                    }
                } else {
                    action.loop = v3d[loop];
                    action.repetitions = Infinity;
                }

                scene = PzLib.getSceneByAction(action);
                frameRate = PzLib.getSceneAnimFrameRate(scene);
                timeScale = Math.abs(parseFloat(speed));

                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                callbacks = _pGlob.animMixerCallbacks;
                let found = false;
                for (let j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            callbacks = _pGlob.animMixerCallbacks;
            for (let j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--;
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            scene = PzLib.getSceneByAction(action);
            frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, useID, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        useID: useID,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        let isPicked = false;

        const maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (let i = 0; i < maxIntersects; i++) {
            const obj = intersects[i].object;

            const objName = PzLib.getObjectName(obj);
            const objUUID = PzLib.getObjectUUID(obj);
            const objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objUUID, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = useID ? objUUID : objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// loadMedia puzzle
function loadMedia_WebAudio(url) {
    if (!v3d.Detector.checkWebAudio()) {
        if (!_pGlob.noWebAudioReported) {
            _pGlob.noWebAudioReported = true;
            console.error('load sound: Web Audio API not supported');
        }
        return null;
    }

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new PzLib.AudioWebAudio().load(url);
    }
    return elems[url];
}

// playSound puzzle
function playSound(mediaElem, loop) {
    const mediaElems = (Array.isArray(mediaElem) ? mediaElem : [mediaElem]).filter(elem => elem);
    mediaElems.forEach(mediaElem => {
        mediaElem.setLoop(loop);
        if (mediaElem.audio)
            mediaElem.audio.context.resume();
        mediaElem.play();
    });
}

// whenHovered puzzle
PzLib.initObjectPicking(function(intersects, event) {

    const prevHovered = _pGlob.hoveredObject;
    let currHovered = '';

    // the event might happen before hover registration
    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    // search for closest hovered object

    let lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        const maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (let i = 0; i < maxIntersects; i++) {
            const obj = intersects[i].object;
            const objName = PzLib.getObjectName(obj);

            if (PzLib.isObjectAmongObjects(objName, PzLib.retrieveObjectNames(el.objSelector)) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(prevHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(currHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove');

// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}

// domObjectCall puzzle
function domObjectCallElement(method, id, isParent, data) {
    let elem = PzLib.getElement(id, isParent);
    if (!elem) {
        // do not clutter console with errors when accessing elements in parent frame
        if (!isParent)
            console.error('call method puzzle: Invalid element');
        return;
    }

    switch (method) {
    case 'BLUR':
        elem.blur();
        break;
    case 'CLICK':
        elem.click();
        break;
    case 'CLOSE':
        elem.close();
        break;
    case 'SHOW':
        elem.show();
        break;
    case 'SHOW_MODAL':
        elem.showModal();
        break;
    case 'FOCUS':
        elem.focus();
        break;
    case 'POST_MESSAGE':
        // allow posting to iframe elements directly
        const win = (elem.contentWindow !== undefined) ? elem.contentWindow : elem;
        if (win && win.postMessage)
            win.postMessage(data, '*');
        else if (!isParent)
            console.error('call method puzzle: Invalid element');
        break;
    }
}


registerSetTimeout(0.3, function() {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('window.is3DLoaded = true;' + '\n' +
    'console.log("is3DLoaded set:", window.is3DLoaded);' + '\n' +
    '')))(appInstance, v3d, PL, VARS, PROC);

});

registerSetTimeout(0.5, function() {
    maincamera_defpos = getObjTransform('camera_main', false, 'position', 'xyz');
    maincamera_targetdefpos = getObjTransform('camera_main.Target', false, 'position', 'xyz');
});

/* screenshot quick button */
eventHTMLElem('click', ['screenshot_desktop', 'screenshot_summary', 'screenshot_mobile'], true, function(event) {
    downloadFile(appInstance.renderer.domElement.toDataURL('image/png'), 'screenshot.png');
});

registerSetTimeout(0.5, function() {
    maincamera_defpos = getObjTransform('camera_main', false, 'position', 'xyz');
    maincamera_targetdefpos = getObjTransform('camera_main.Target', false, 'position', 'xyz');
    rearcamera_pos = getObjTransform('camera_rear', false, 'position', 'xyz');
    rearcamera_targetpos = getObjTransform('camera_rear.Target', false, 'position', 'xyz');
    middlecamera_pos = getObjTransform('camera_middle', false, 'position', 'xyz');
    middlecamera_targetpos = getObjTransform('camera_middle.Target', false, 'position', 'xyz');
    bottomcamera_pos = getObjTransform('camera_bottom', false, 'position', 'xyz');
    bottomcamera_tagetpos = getObjTransform('camera_bottom.Target', false, 'position', 'xyz');
});

/* def view quick button */
eventHTMLElem('click', ['defaul_view_desktop', 'defaul_view_mobile'], true, function(event) {
    camera_defpos();
});

/* water surface quick button */
eventHTMLElem('click', ['d_water_surface_desktop', 'e_water_surface_desktop'], true, function(event) {
    if (isObjectVisible('water_surface')) {
        changeVis('water_surface', false);
    } else {
        changeVis('water_surface', true);
    }
});

/* features quick button */
eventHTMLElem('click', ['d_toggle_features', 'e_toggle_features'], true, function(event) {
    if (isObjectVisible(['GROUP', 'Triggers'])) {
        changeVis(['GROUP', 'Triggers'], false);
    } else {
        changeVis(['GROUP', 'Triggers'], true);
    }
});

setCSSRuleStyle('backgroundImage', 'url("INFO2.jpg")', '.v3d-annotation', false, '');
setCSSRuleStyle('backgroundSize', 'contain', '.v3d-annotation', false, '');
setCSSRuleStyle('borderRadius', '0px', '.v3d-annotation', false, '');
setCSSRuleStyle('backgroundPosition', 'center', '.v3d-annotation', false, '');

j;

pvc_roughness = 0.4;
hypalon_roughness = 0.55;

/* Tube pvc light gray */
eventHTMLElem('click', ['e_tube_color_light_gray_pvc', 'd_tube_color_light_gray_pvc'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', pvc_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#BABABA');
    non_carbon_pvc();
    tube_color_lightgray2();
});
/* Tube pvc black */
eventHTMLElem('click', ['e_tube_color_black_gray_pvc', 'd_tube_color_black_gray_pvc'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', pvc_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#1A1A1A');
    non_carbon_pvc();
    tube_color_black2();
});
/* Tube pvc dark gray */
eventHTMLElem('click', ['e_tube_color_dark_gray_pvc', 'd_tube_color_dark_gray_pvc'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', pvc_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#434343');
    non_carbon_pvc();
    tube_color_darkgray2();
});

/* decor black */
eventHTMLElem('click', ['e_tube_decor_black_carbon_hypalon', 'd_tube_decor_black_carbon_hypalon'], true, function(event) {
    if (tube_color == tube_color_ice) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#DFDFDF');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#1A1A1A');
    }
    if (tube_color == tube_color_offwhite) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#1A1A1A');
    }
    if (tube_color == tube_color_lightgray || tube_color == tube_color_darkgray) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#87999F');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#1A1A1A');
    }
    if (tube_color == tube_color_black) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#1A1A1A');
    }
});

pvc_roughness;

eventHTMLElem('click', ['d_fiberglass_dashboard_white', 'e_fiberglass_dashboard_white'], true, function(event) {
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_gelcoat', undefined);
    setMaterialColor('m_dash_gelcoat', 'm_dash_gelcoat Base Color', 0, 0, 0, '#e6e6e6');
});
eventHTMLElem('click', ['d_fiberglass_dashboard_off_white', 'e_fiberglass_dashboard_off_white'], true, function(event) {
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_gelcoat', undefined);
    setMaterialColor('m_dash_gelcoat', 'm_dash_gelcoat Base Color', 0, 0, 0, '#cacab4');
});
eventHTMLElem('click', ['d_fiberglass_dashboard_light_gray', 'e_fiberglass_dashboard_light_gray'], true, function(event) {
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_gelcoat', undefined);
    setMaterialColor('m_dash_gelcoat', 'm_dash_gelcoat Base Color', 0, 0, 0, '#BABABA');
});
eventHTMLElem('click', ['d_fiberglass_dashboard_metallic', 'e_fiberglass_dashboard_metallic'], true, function(event) {
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_metal', undefined);
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_metal', undefined);
});
eventHTMLElem('click', ['d_fiberglass_dashboard_dark_gray', 'e_fiberglass_dashboard_dark_gray'], true, function(event) {
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_gelcoat', undefined);
    setMaterialColor('m_dash_gelcoat', 'm_dash_gelcoat Base Color', 0, 0, 0, '#434343');
});
eventHTMLElem('click', ['d_fiberglass_dashboard_black', 'e_fiberglass_dashboard_black'], true, function(event) {
    assignMat(['GROUP', 'sel_dashboard'], 'm_dash_gelcoat', undefined);
    setMaterialColor('m_dash_gelcoat', 'm_dash_gelcoat Base Color', 0, 0, 0, '#1A1A1A');
});

eventHTMLElem('click', ['d_upholstery_ice', 'e_upholstery_ice'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#D2D2D2');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#D2D2D2');
});
eventHTMLElem('click', ['d_upholstery_plate', 'e_upholstery_plate'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#8D8D8D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#8D8D8D');
});
eventHTMLElem('click', ['d_upholstery_macadamia', 'e_upholstery_macadamia'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#a65c41');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#a65c41');
});
eventHTMLElem('click', ['d_upholstery_taupe', 'e_upholstery_taupe'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#80735E');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#80735E');
});
eventHTMLElem('click', ['d_upholstery_wine', 'e_upholstery_wine'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#691726');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#691726');
});
eventHTMLElem('click', ['d_upholstery_mandarin', 'e_upholstery_mandarin'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#99543d');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#99543d');
});
eventHTMLElem('click', ['d_upholstery_lime', 'e_upholstery_lime'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#8c8c3f');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#8c8c3f');
});
eventHTMLElem('click', ['d_upholstery_cerulean', 'e_upholstery_cerulean'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#586a80');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#586a80');
});
eventHTMLElem('click', ['d_upholstery_black', 'e_upholstery_black'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#2D2D2D');
});

eventHTMLElem('click', ['d_upholstery_black_black', 'e_upholstery_black_black'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#2D2D2D');
});
eventHTMLElem('click', ['d_upholstery_black_wine', 'e_upholstery_black_wine'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#691726');
});
eventHTMLElem('click', ['d_upholstery_black_mandarin', 'e_upholstery_black_mandarin'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#99543d');
});
eventHTMLElem('click', ['d_upholstery_black_lime', 'e_upholstery_black_lime'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#8c8c3f');
});
eventHTMLElem('click', ['d_upholstery_black_cerulean', 'e_upholstery_black_cerulean'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#586a80');
});
eventHTMLElem('click', ['d_upholstery_black_graphite', 'e_upholstery_black_graphite'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#474747');
});
eventHTMLElem('click', ['d_upholstery_graphite_taupe', 'e_upholstery_graphite_taupe'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#474747');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#80735E');
});
eventHTMLElem('click', ['d_upholstery_graphite_macadamia', 'e_upholstery_graphite_macadamia'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#474747');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#969082');
});
eventHTMLElem('click', ['d_upholstery_graphite_plate', 'e_upholstery_graphite_plate'], true, function(event) {
    setMaterialColor('m_cusion_color1', 'm_cusion_color1 Base Color', 0, 0, 0, '#474747');
    setMaterialColor('m_cusion_color2', 'm_cusion_color2 Base Color', 0, 0, 0, '#8D8D8D');
});

eventHTMLElem('click', ['d_other_colors_metal_regular_polished', 'e_other_colors_metal_regular_polished'], true, function(event) {
    assignMat(['GROUP', 'sel_polish_metal'], 'm_metal_polish', undefined);
});
eventHTMLElem('click', ['d_other_colors_metal_black_powder_coated', 'e_other_colors_metal_black_powder_coated'], true, function(event) {
    assignMat(['GROUP', 'sel_polish_metal'], 'm_metal_black', undefined);
});

/* Gelcoat */
eventHTMLElem('click', ['d_fiberglass_gelcoat_white', 'e_fiberglass_gelcoat_white'], true, function(event) {
    setMaterialColor('m_gelcoat', 'm_gelcoat Base Color', 0, 0, 0, '#e6e6e6');
});
eventHTMLElem('click', ['e_fiberglass_gelcoat_off_white', 'd_fiberglass_gelcoat_off_white'], true, function(event) {
    setMaterialColor('m_gelcoat', 'm_gelcoat Base Color', 0, 0, 0, '#cacab4');
});
eventHTMLElem('click', ['e_fiberglass_gelcoat_light_gray', 'd_fiberglass_gelcoat_light_gray'], true, function(event) {
    setMaterialColor('m_gelcoat', 'm_gelcoat Base Color', 0, 0, 0, '#BABABA');
});
eventHTMLElem('click', ['e_fiberglass_gelcoat_dark_gray', 'd_fiberglass_gelcoat_dark_gray'], true, function(event) {
    setMaterialColor('m_gelcoat', 'm_gelcoat Base Color', 0, 0, 0, '#434343');
});
eventHTMLElem('click', ['e_fiberglass_gelcoat_black', 'd_fiberglass_gelcoat_black'], true, function(event) {
    setMaterialColor('m_gelcoat', 'm_gelcoat Base Color', 0, 0, 0, '#1A1A1A');
});

eventHTMLElem('click', ['d_other_colors_seadek_mocha_black', 'e_other_colors_seadek_mocha_black'], true, function(event) {
    setMaterialColor('m_seadeck_color1b', 'm_seadeck_color1b Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_seadeck_color2', 'm_seadeck_color2 Base Color', 0, 0, 0, '#8A8B77');
});
eventHTMLElem('click', ['d_other_colors_seadek_black_black', 'e_other_colors_seadek_black_black'], true, function(event) {
    setMaterialColor('m_seadeck_color1b', 'm_seadeck_color1b Base Color', 0, 0, 0, '#232323');
    setMaterialColor('m_seadeck_color2', 'm_seadeck_color2 Base Color', 0, 0, 0, '#2D2D2D');
});
eventHTMLElem('click', ['d_other_colors_seadek_black_gray', 'e_other_colors_seadek_black_gray'], true, function(event) {
    setMaterialColor('m_seadeck_color1b', 'm_seadeck_color1b Base Color', 0, 0, 0, '#949494');
    setMaterialColor('m_seadeck_color2', 'm_seadeck_color2 Base Color', 0, 0, 0, '#2D2D2D');
});
eventHTMLElem('click', ['d_other_colors_seadek_gray_black', 'e_other_colors_seadek_gray_black'], true, function(event) {
    setMaterialColor('m_seadeck_color1b', 'm_seadeck_color1b Base Color', 0, 0, 0, '#2D2D2D');
    setMaterialColor('m_seadeck_color2', 'm_seadeck_color2 Base Color', 0, 0, 0, '#949494');
});

'#434343';

/* Ice White HYPALON */
// Ice White HYPALON
eventHTMLElem('click', ['d_tube_color_ice_white_hypalon', 'e_tube_color_ice_white_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', hypalon_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#DFDFDF');
    non_carbon_pvc();
    tube_color_ice2();
});
/* OFF White HYPALON */
eventHTMLElem('click', ['d_tube_color_off_white_hypalon', 'e_tube_color_off_white_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', hypalon_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#cacab4');
    non_carbon_pvc();
    tube_color_off_white();
});
/* Arctic Gray HYPALON */
eventHTMLElem('click', ['d_tube_color_arctic_gray_hypalon', 'e_tube_color_arctic_gray_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', hypalon_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#777777');
    non_carbon_pvc();
    tube_color_lightgray2();
});
/* military_gray HYPALON */
eventHTMLElem('click', ['d_tube_color_military_gray_hypalon', 'e_tube_color_military_gray_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', hypalon_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#61626b');
    non_carbon_pvc();
    tube_color_darkgray2();
});
/* black HYPALON */
eventHTMLElem('click', ['d_tube_color_black_hypalon', 'e_tube_color_black_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', hypalon_roughness);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#1A1A1A');
    non_carbon_pvc();
    tube_color_black2();
});
/* Military Gray FI HYPALON */
eventHTMLElem('click', ['d_tube_color_military_gray_fi_hypalon', 'e_tube_color_military_gray_fi_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', 0.7);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#61626b');
    non_carbon_pvc();
    tube_color_darkgray2();
});
/* Black FI HYPALON */
eventHTMLElem('click', ['d_tube_color_black_fi_hypalon', 'e_tube_color_black_fi_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', 0.7);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#262626');
    non_carbon_pvc();
    tube_color_black2();
});
/* Black Carbon HYPALON */
eventHTMLElem('click', ['d_tube_color_black_carbon_hypalon', 'e_tube_color_black_carbon_hypalon'], true, function(event) {
    setMaterialValue('m_pvc_base', 'm_pvc_base_Roughness', 0.5);
    setMaterialValue('m_pvc_base', 'normal_pvc_MIX_MixAmount', 1);
    setMaterialColor('m_pvc_base', 'm_pvc_base Base Color', 0, 0, 0, '#262626');
    tube_color_black2();
});

/* decor gray */
eventHTMLElem('click', ['e_tube_decor_gray_carbon_hypalon', 'd_tube_decor_gray_carbon_hypalon'], true, function(event) {
    if (tube_color == tube_color_ice) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#434343');
    }
    if (tube_color == tube_color_lightgray) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#434343');
    }
    if (tube_color == tube_color_black) {
        setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#1A1A1A');
        setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#434343');
        setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#434343');
    }
});

/* decor white */
eventHTMLElem('click', ['e_tube_decor_white_carbon_hypalon', 'd_tube_decor_white_carbon_hypalon'], true, function(event) {
    setMaterialColor('tube_decor_brus', 'tube_decor_brus Base Color', 0, 0, 0, '#1A1A1A');
    setMaterialColor('tube_decor_line', 'tube_decor_line Base Color', 0, 0, 0, '#DFDFDF');
    setMaterialColor('tube_decor_arrow', 'tube_decor_arrow Base Color', 0, 0, 0, '#DFDFDF');
    setMaterialColor('tube_decor_logo', 'tube_decor_logo Base Color', 0, 0, 0, '#DFDFDF');
    setMaterialColor('tube_decor_handle', 'tube_decor_handle Base Color', 0, 0, 0, '#1A1A1A');
});

eventHTMLElem('click', ['d_swimming_platforms', 'e_swimming_platforms'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_swimming_platform_rear_'])) {
        changeVis(['GROUP', 'opt_swimming_platform_rear_'], false);
    } else {
        changeVis(['GROUP', 'opt_swimming_platform_rear_'], true);
    }
    if (isObjectVisible(['GROUP', 'opt_seadeck']) && isObjectVisible(['GROUP', 'opt_swimming_platform_rear_'])) {
        changeVis(['GROUP', 'opt_seadeck_for_platform'], true);
    } else {
        changeVis(['GROUP', 'opt_seadeck_for_platform'], false);
    }
});
eventHTMLElem('click', ['d_bowrailing', 'e_bowrailing'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_railings'])) {
        changeVis(['GROUP', 'opt_railings'], false);
    } else {
        changeVis(['GROUP', 'opt_railings'], true);
    }
});
eventHTMLElem('click', ['d_waterski_mast', 'e_waterski_mast'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_waterski_mast'])) {
        changeVis(['GROUP', 'opt_waterski_mast'], false);
    } else {
        changeVis(['GROUP', 'opt_waterski_mast'], true);
    }
});
eventHTMLElem('click', ['d_hydraulic_sys', 'e_hydraulic_sys'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_steering_system'])) {
        changeVis(['GROUP', 'opt_steering_system'], false);
    } else {
        changeVis(['GROUP', 'opt_steering_system'], true);
    }
});
eventHTMLElem('click', ['d_prem_wheel', 'e_prem_wheel'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_steering_wheel'])) {
        changeVis(['GROUP', 'opt_steering_wheel'], false);
    } else {
        changeVis(['GROUP', 'opt_steering_wheel'], true);
    }
});
eventHTMLElem('click', ['d_bow_sundeck', 'e_bow_sundeck'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_sundeck_bow'])) {
        changeVis(['GROUP', 'opt_sundeck_bow'], false);
    } else {
        changeVis(['GROUP', 'opt_sundeck_bow'], true);
    }
});
eventHTMLElem('click', ['d_rear_sundeck', 'e_rear_sundeck'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_sundeck_rear'])) {
        changeVis(['GROUP', 'opt_sundeck_rear'], false);
    } else {
        changeVis(['GROUP', 'opt_sundeck_rear'], true);
    }
});

eventHTMLElem('click', ['d_removable_table', 'e_removable_table'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_table'])) {
        changeVis(['GROUP', 'opt_table'], false);
    } else {
        changeVis(['GROUP', 'opt_table'], true);
    }
});
eventHTMLElem('click', ['d_freshwater_set_shower', 'e_freshwater_set_shower'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_shower'])) {
        changeVis(['GROUP', 'opt_shower'], false);
    } else {
        changeVis(['GROUP', 'opt_shower'], true);
    }
});
eventHTMLElem('click', ['d_freshwater_set_shower_sink_faucet', 'e_freshwater_set_shower_sink_faucet'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_sink'])) {
        changeVis(['GROUP', 'opt_sink'], false);
        changeVis(['GROUP', 'opt_shower'], false);
        changeVis('opt_NOsink', true);
    } else {
        changeVis(['GROUP', 'opt_sink'], true);
        changeVis(['GROUP', 'opt_shower'], true);
        changeVis('opt_NOsink', false);
    }
});
eventHTMLElem('click', ['d_refrigerator_freezer', 'e_refrigerator_freezer'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_refridge'])) {
        changeVis(['GROUP', 'opt_refridge'], false);
        changeVis('opt_shelf', true);
    } else {
        changeVis(['GROUP', 'opt_refridge'], true);
        changeVis('opt_shelf', false);
    }
});
eventHTMLElem('click', ['d_anchor_set', 'e_anchor_set'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_archor'])) {
        changeVis(['GROUP', 'opt_archor'], false);
    } else {
        changeVis(['GROUP', 'opt_archor'], true);
    }
});
eventHTMLElem('click', ['d_canvas_bimini_top', 'e_canvas_bimini_top'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_biminitop'])) {
        changeVis(['GROUP', 'opt_biminitop'], false);
    } else {
        changeVis(['GROUP', 'opt_biminitop'], true);
    }
});
eventHTMLElem('click', ['e_rigid_hard_top', 'd_rigid_hard_top'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_hardtop'])) {
        changeVis(['GROUP', 'opt_hardtop'], false);
        changeVis('opt_no_hardtop', true);
    } else {
        changeVis(['GROUP', 'opt_hardtop'], true);
        changeVis('opt_no_hardtop', false);
    }
});
eventHTMLElem('click', ['d_bow_sun_top', 'e_bow_sun_top'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_suntop_bow'])) {
        changeVis(['GROUP', 'opt_suntop_bow'], false);
    } else {
        changeVis(['GROUP', 'opt_suntop_bow'], true);
    }
});
eventHTMLElem('click', ['d_rear_sun_top', 'e_rear_sun_top'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_suntop_rear'])) {
        changeVis(['GROUP', 'opt_suntop_rear'], false);
    } else {
        changeVis(['GROUP', 'opt_suntop_rear'], true);
    }
});

eventHTMLElem('click', ['d_swimming_platforms_info', 'e_swimming_platforms_info'], true, function(event) {
    tweenCamera(rearcamera_pos, rearcamera_targetpos, 1, function() {
        if (isObjectVisible(['GROUP', 'opt_swimming_platform_rear_'])) {
            operateAnimation('PLAY', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], 0, 40, 'LoopOnce', 0.4, function() {
                registerSetTimeout(3, function() {
                    operateAnimation('STOP', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], null, null, 'AUTO', 1, function() {}, false);
                });
            }, false);
        } else {
            changeVis(['GROUP', 'opt_swimming_platform_rear_'], true);
            operateAnimation('PLAY', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], 0, 40, 'LoopOnce', 0.4, function() {
                registerSetTimeout(3, function() {
                    changeVis(['GROUP', 'opt_swimming_platform_rear_'], false);
                    operateAnimation('STOP', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], null, null, 'AUTO', 1, function() {}, false);
                });
            }, false);
        }
    }, 0);
    registerSetTimeout(5, function() {
        camera_defpos();
    });
});

eventHTMLElem('click', ['d_seadek_soft_anti_skid', 'e_seadek_soft_anti_skid'], true, function(event) {
    if (isObjectVisible(['GROUP', 'opt_seadeck'])) {
        changeVis(['GROUP', 'opt_seadeck'], false);
        changeVis(['GROUP', 'opt_seadeck_left_rear_locker'], false);
        changeVis(['GROUP', 'opt_seadeck_right_rear_locker'], false);
        if (isObjectVisible(['GROUP', 'opt_swimming_platform_rear_'])) {
            changeVis(['GROUP', 'opt_seadeck_for_platform'], false);
        } else {
        }
    } else {
        changeVis(['GROUP', 'opt_seadeck'], true);
        changeVis(['GROUP', 'opt_seadeck_right_rear_locker'], true);
        changeVis(['GROUP', 'opt_seadeck_left_rear_locker'], true);
        if (isObjectVisible(['GROUP', 'opt_swimming_platform_rear_'])) {
            changeVis(['GROUP', 'opt_seadeck_for_platform'], true);
        } else {
            changeVis(['GROUP', 'opt_seadeck_for_platform'], false);
        }
    }
});

eventHTMLElem('click', ['d_freshwater_set_shower_sink_faucet_info', 'e_freshwater_set_shower_sink_faucet_info'], true, function(event) {
    tweenCamera(middlecamera_pos, middlecamera_targetpos, 1, function() {
        if (isObjectVisible(['GROUP', 'opt_sink'])) {
            operateAnimation('PLAY', ['anim_sink_locker_Gelcoat', 'anim_sink_faucet_1_metal', 'anim_sink_faucet_2_metal'], 0, 50, 'LoopOnce', 1, function() {
                operateAnimation('PLAY', ['anim_sink_locker_Gelcoat', 'anim_sink_faucet_1_metal', 'anim_sink_faucet_2_metal'], 0, 60, 'LoopOnce', 2, function() {}, true);
            }, false);
        } else {
            changeVis(['GROUP', 'opt_sink'], true);
            operateAnimation('PLAY', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], 0, 40, 'LoopOnce', 0.4, function() {
                registerSetTimeout(3, function() {
                    changeVis(['GROUP', 'opt_sink'], false);
                    operateAnimation('STOP', ['anim_sink_locker_Gelcoat', 'anim_sink_faucet_1_metal', 'anim_sink_faucet_2_metal'], null, null, 'AUTO', 1, function() {}, false);
                });
            }, false);
        }
    }, 0);
    registerSetTimeout(5, function() {
        camera_defpos();
    });
});

eventHTMLElem('click', ['d_refrigerator_freezer_info', 'e_refrigerator_freezer_info'], true, function(event) {
    tweenCamera(middlecamera_pos, middlecamera_targetpos, 1, function() {
        if (isObjectVisible(['GROUP', 'opt_refridge'])) {
        } else {
            changeVis(['GROUP', 'opt_refridge'], true);
            changeVis('opt_shelf', false);
            registerSetTimeout(4, function() {
                changeVis(['GROUP', 'opt_refridge'], false);
                changeVis('opt_shelf', true);
            });
        }
    }, 0);
    registerSetTimeout(5, function() {
        camera_defpos();
    });
});

eventHTMLElem('click', ['d_anchor_set_info', 'e_anchor_set_info'], true, function(event) {
    tweenCamera(bottomcamera_pos, bottomcamera_tagetpos, 1, function() {
        if (isObjectVisible(['GROUP', 'opt_archor'])) {
        } else {
            changeVis(['GROUP', 'opt_archor'], true);
            registerSetTimeout(4, function() {
                changeVis(['GROUP', 'opt_archor'], false);
            });
        }
    }, 0);
    registerSetTimeout(5, function() {
        camera_defpos();
    });
});

registerOnClick('trigger_bow_anchorlocker', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', ['anim_bow_anchorlockert_Gelcoat', null, null], 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', ['anim_bow_anchorlockert_Gelcoat', null, null], 0, 60, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_bow_locker', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_bow_locker_Gelcoat', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_bow_locker_Gelcoat', 0, 60, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_console_door', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_consoleseat_Gelcoat', 0, 25, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_consoleseat_Gelcoat', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_console_locker', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_consollocker_dashboard', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_consollocker_dashboard', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_driver_rightseat', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_right_driverseat_metal', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_right_driverseat_metal', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_driver_leftseat', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_left_driverseat_metal', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_left_driverseat_metal', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_sink', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', ['anim_sink_locker_Gelcoat', 'anim_sink_faucet_1_metal', 'anim_sink_faucet_2_metal'], 0, 50, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', ['anim_sink_locker_Gelcoat', 'anim_sink_faucet_1_metal', 'anim_sink_faucet_2_metal'], 0, 60, 'LoopOnce', 2, function() {}, true);
    }, false);
}, function(event) {});

registerOnClick(['GROUP', 'Triggers'], false, false, [0,1,2], false, function(event) {
    playSound(loadMedia_WebAudio('./sounds/seat_opening.mp3'), false);
}, function(event) {});

registerOnClick('trigger_rear_left_seat', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_rear_left_seat_Gelcoat', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_rear_left_seat_Gelcoat', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_rear_central_seat', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_rear_central_seat_Gelcoat', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_rear_central_seat_Gelcoat', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_rear_right_seat', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_rear_right_seat_Gelcoat', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_rear_right_seat_Gelcoat', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});

registerOnHover(['GROUP', 'Triggers'], false, function(event) {
    operateAnimation('PLAY', _pGlob.hoveredObject, null, null, 'LoopOnce', 1, function() {}, false);
}, function(event) {});

registerOnClick('trigger_stairs', false, false, [0,1,2], false, function(event) {
    if (isObjectVisible(['GROUP', 'opt_swimming_platform_rear_'])) {
        operateAnimation('PLAY', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], 0, 40, 'LoopOnce', 0.4, function() {
            registerSetTimeout(3, function() {
                operateAnimation('STOP', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], null, null, 'AUTO', 1, function() {}, false);
            });
        }, false);
    } else {
        domObjectCallElement('CLICK', 'toggle-hide-menu', true, undefined);
        changeVis(['GROUP', 'opt_swimming_platform_rear_'], true);
        operateAnimation('PLAY', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], 0, 40, 'LoopOnce', 0.4, function() {
            registerSetTimeout(3, function() {
                changeVis(['GROUP', 'opt_swimming_platform_rear_'], false);
                operateAnimation('STOP', ['stairs_anim3_metal_base_003', 'stairs_anim2_metal_base_002', 'stairs_anim1_dm'], null, null, 'AUTO', 1, function() {}, false);
                domObjectCallElement('CLICK', 'toggle-hide-menu', true, undefined);
            });
        }, false);
    }
}, function(event) {});

registerOnClick('trigger_rear_locker_left', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_rear_locker_left_Gelcoat', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_rear_locker_left_Gelcoat', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});
registerOnClick('trigger_rear_right_locker', false, false, [0,1,2], false, function(event) {
    operateAnimation('PLAY', 'anim_rear_locker_right_Gelcoat', 0, 35, 'LoopOnce', 1, function() {
        operateAnimation('PLAY', 'anim_rear_locker_right_Gelcoat', 0, 50, 'LoopOnce', 1, function() {}, true);
    }, false);
}, function(event) {});

registerOnClick('trigger_engine', false, false, [0,1,2], false, function(event) {
    if (isObjectVisible('engine_glass_opt__100')) {
        changeVis('engine_glass_opt__100', false);
    } else {
        changeVis('engine_glass_opt__100', true);
    }
}, function(event) {});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
